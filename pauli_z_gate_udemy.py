# -*- coding: utf-8 -*-
"""pauli-z-gate-udemy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bN1cIisv03mQ7kL9HBVo9maZ9F1f9IkZ
"""

pip install qiskit

pip install pylatexenc

pip install matplotlib==3.5.1 #required for bloch sphere and q sphere figures

#pip install git+https://github.com/qiskit-community/qiskit-textbook.git#subdirectory=qiskit-textbook-src

# Commented out IPython magic to ensure Python compatibility.
import qiskit
import numpy as np
from numpy import pi
from qiskit import *
from qiskit.tools.visualization import plot_histogram, plot_state_qsphere, plot_bloch_multivector
from qiskit.tools.monitor import job_monitor
# %matplotlib inline
from qiskit.quantum_info import Statevector #for statevector
from qiskit.visualization import array_to_latex

from qiskit import transpile
from qiskit.providers.aer import AerSimulator

from qiskit import IBMQ, Aer

qiskit.__qiskit_version__

qc1=QuantumCircuit(1)
## appy pauli z gate , on the qubit 
qc1.z(0)

qc1.draw('mpl')

## for output , there is something called AER : which is used in simulations##
##
# get the backend to execute ( simulator type)
backend = Aer.get_backend('statevector_simulator')
##execute the circuit using  the backend 
out= execute(qc1,backend).result().get_statevector()

#plot the result as bloch sphere visualization 
plot_bloch_multivector(out)

from qiskit.visualization import visualize_transition

visualize_transition(qc1)

## apply x gate then z gate 
qc2=QuantumCircuit(1)
## first apply x gate 
qc2.x(0)
## appy pauli z gate , on the qubit 
qc2.z(0)

qc2.draw('mpl')

## for output , there is something called AER : which is used in simulations##
##
# get the backend to execute ( simulator type)
backend = Aer.get_backend('statevector_simulator')
##execute the circuit using  the backend 
out= execute(qc2,backend).result().get_statevector()

#plot the result as bloch sphere visualization 
plot_bloch_multivector(out)

visualize_transition(qc2)

